"""
Simulations to generate electrode grids and simulate fish movement
and electric organ discharge (EOD) waveforms, including chirps and rises.
Most of the code concerning EOD generation is just slightly modified from
the original code by Jan Benda et al. in the thunderfish package. The original
code can be found here: https://github.com/janscience/thunderfish
"""

from dataclasses import dataclass, field
from typing import List

import matplotlib.pyplot as plt
import numpy as np
from rich.console import Console

np.random.seed(42)

console = Console()


@dataclass
class ChirpParams:
    """
    All parameters for simulating the frequency trace of chirps.
    """

    eodf: float = 0
    samplerate: float = 44100.0
    duration: float = 0.2
    chirp_times: List[float] = field(default_factory=lambda: np.array([0.1]))
    chirp_sizes: List[float] = field(default_factory=lambda: np.array([100.0]))
    chirp_widths: List[float] = field(default_factory=lambda: np.array([0.01]))
    chirp_undershoots: List[float] = field(
        default_factory=lambda: np.array([0.1])
    )
    chirp_kurtosis: List[float] = field(default_factory=lambda: np.array([1.0]))
    chirp_contrasts: List[float] = field(
        default_factory=lambda: np.array([0.05])
    )


@dataclass
class RiseParams:
    """
    All parameters for simulating the frequency trace of rises.
    """

    eodf: float = 0
    samplerate: float = 44100.0
    duration: float = 5.0
    rise_times: List[float] = field(default_factory=lambda: np.array([0.5]))
    rise_sizes: List[float] = field(default_factory=lambda: np.array([80.0]))
    rise_taus: List[float] = field(default_factory=lambda: np.array([0.01]))
    decay_taus: List[float] = field(default_factory=lambda: np.array([0.1]))




def make_chirps(params: ChirpParams) -> tuple[np.ndarray, np.ndarray]:
    """Simulate frequency trace with chirps. Original code by Jan Benda et al.

    I just added an undershoot parameter to the chirp model.

    A chirp is modeled as a combination of 2 Gaussians. This model is used to
    easily simulate chirps "by hand". The first Gaussian is
    centered at the chirp time and has a width of chirp_width. The second Gaussian
    is centered at chirp_time + chirp_width / 2 and has the same width but a
    smaller amlitude determined by chirp_undershoot, which is a factor that
    is multiplied with the amplitude of the first Gaussian.

    The result is a classical Type II chirp with a small undershoot.

    Parameters
    ----------
    params : ChirpParams
        Parameters for simulating the frequency trace with chirps.

    Returns
    -------
    frequency : np.ndarray
        Generated frequency trace that can be passed on to wavefish_eods().
    amplitude : np.ndarray
        Generated amplitude modulation that can be used to multiply the trace
        generated by wavefish_eods().
    """
    n = int(params.duration * params.samplerate)
    frequency = params.eodf * np.ones(n)
    amplitude = np.ones(n)

    for time, width, undershoot, size, kurtosis, contrast in zip(
        params.chirp_times,
        params.chirp_widths,
        params.chirp_undershoots,
        params.chirp_sizes,
        params.chirp_kurtosis,
        params.chirp_contrasts,
    ):
        chirp_t = np.arange(-3.0 * width, 3.0 * width, 1.0 / params.samplerate)
        g1 = gaussian(chirp_t, mu=0, height=size, width=width, kurt=kurtosis)
        g2 = gaussian(
            chirp_t, mu=width / 2, height=size * undershoot, width=width, kurt=1
        )
        gauss = g1 - g2

        index = int(time * params.samplerate)
        i0 = index - len(gauss) // 2
        i1 = i0 + len(gauss)
        gi0 = 0
        gi1 = len(gauss)
        if i0 < 0:
            gi0 -= i0
            i0 = 0
        if i1 >= len(frequency):
            gi1 -= i1 - len(frequency)
            i1 = len(frequency)
        frequency[i0:i1] += gauss[gi0:gi1]
        amplitude[i0:i1] -= contrast * gauss[gi0:gi1] / size

    return frequency, amplitude


def make_rises(params: RiseParams) -> np.ndarray:
    """
    Simulate frequency trace with rises. Original code by Jan Benda et al.

    A rise is modeled as a double exponential frequency modulation.

    Parameters
    ----------
    params : RisesParams
        A dataclass containing the parameters for simulating the frequency trace
        with rises.

    Returns
    -------
    numpy.ndarray
        Generate frequency trace that can be passed on to wavefish_eods().
    """
    n = int(params.duration * params.samplerate)

    # baseline eod frequency:
    frequency = params.eodf * np.ones(n)

    for time, size, riset, decayt in zip(
        params.rise_times,
        params.rise_sizes,
        params.rise_taus,
        params.decay_taus,
    ):
        # rise frequency waveform:
        rise_t = np.arange(0.0, 10.0 * decayt, 1.0 / params.samplerate)
        rise = size * (1.0 - np.exp(-rise_t / riset)) * np.exp(-rise_t / decayt)

        # add rises on baseline eodf:
        index = int(time * params.samplerate)
        if index + len(rise) > len(frequency):
            rise_index = len(frequency) - index
            frequency[index : index + rise_index] += rise[:rise_index]
            break
        frequency[index : index + len(rise)] += rise
    return frequency


def communication_demo() -> None:
    """Demo of chirp and rise simulations."""
    cp = ChirpParams()
    rp = RiseParams()
    cf, ca = make_chirps(cp)
    rf = make_rises(rp)

    fig, (ax1, ax2, ax3) = plt.subplots(3, 1, constrained_layout=True)
    ax1.plot(cf)
    ax1.set_title("Frequency trace of chirp")
    ax2.plot(ca)
    ax2.set_title("Amplitude modulation of chirp")
    ax3.plot(rf)
    ax3.set_title("Frequency trace of rise")
    fig.suptitle("Chirp and rise simulations")
    plt.show()


def main() -> None:
    """Show some demos."""
    communication_demo()


if __name__ == "__main__":
    main()
